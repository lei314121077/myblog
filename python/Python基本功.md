相关的语法之类的解释我就不多做笔记，毕竟对于这些东西都已经烂熟于心，这里我就只做一些用法以及项目开发当中常要用到的一些关于Python基本功的笔记。
# 目录
  * [面向对象](#面向对象)
    * [下划线的应用](#下滑线的应用)
    * [面向对象的三大特性](#面向对象的三大特性)
      * [继承Extend](#继承Extend)
      * [封装和私有化Package](#封装和私有化Package)
      * [多态Polymorphism](#多态Polymorphism)
    * [形参之 *args 和 **kwargs](#形参之 *args 和 **kwargs)
  * [容器异常高阶函数内置函数](*容器异常高阶函数内置函数) 

#面向对象
  
## 面向对象的三大特性

### 继承Extend

  ```python
    class Animal：
      pass

    class Dog(Animal):
      pass

    class Cat(Animal):
      pass

  ```

### 封装和私有化Package
  
  被声明或者被私有化的属性只能在当前类使用， 当然你也可以使用__getattr__或者__setattr__对某个对象进行拆箱和封箱的操作
  
  ```python

    class PythonProperty:

      def __init__(self):
        self.__name = '张三'

      def __python_property(self):
        print 'python hello !'

      def code(self):
        self.__python_property()

  ```

## 多态Polymorphism
  
  例如著名的 repr() 函数，它能够针对输入的任何对象返回一个字符串。这就是多态的代表之一。
  
  ```python
    repr([1,2,3])
    输出: '[1,2,3]'
  ```

  我们再来看看用OOP的思想实现的多态

  ```python

    class Animal:
        def __init__(self, name=""):
            self.name = name

        def talk(self):
            pass

    class Cat(Animal):
        def talk(self):
            print "Meow!"

    class Dog(Animal):
        def talk(self):
            print "Woof!"

    a = Animal()
    a.talk()

    c = Cat("Missy")
    c.talk()

    d = Dog("Rocky")
    d.talk()

  ```

## 下划线的应用

  "单下划线" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；
  "双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。
  
  * _xxx  不能用'from module import *'导入
    
    以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；
  
  * __xxx__ 系统定义名字
    
    以双下划线开头和结尾的（__foo__）代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。
  
  * __xxx 类中的私有变量名
    
    以双下划线开头的（__foo）代表类的私有成员；

  应该尽量避免用下划线作为变量名的开始。

  > 因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx来表示变量是很好的习惯。因为变量名__xxx__对Python里特殊方法专用的标识，如 __init__（）代表类的构造函数。>
  

  
## 形参之 *args 和 **kwargs

  * *args 与 **kwargs

    *args* 接收的是一个元组对象， **kwargs 传递的是一个字典对象

    ```python

    def fun(*args **kwargs){

      print args, 'args_type = %s' % type(args)      #打印出来的类型是一个元组对象
      print kwargs, 'kwargs_type = %s' % type(kwargs) #打印出来的类型是一个字典对象

    }

    ```  



#容器异常高阶函数内置函数

## 容器

  * 列表 list  []
      
    ```python
      list_null = []
      list_int = [1,2,3,4,5,6,7,8,9]
      list_str = ['一', '二', '三', '四', '五', '六']
      list_bol = [True, False, True, Flase]
    ```

    * 添加 append(添加的值) 

      在列表的末尾添加参数

      ```python
        list_int.append(10)
      ```
    
    * 插入 insert(下标位置， 参数的值)

      在指定的位置插入参数

      ```python
        list_int.insert(10, 100)
      ```
    
    * 查看下标的长度 len(要查看的列表)

      ```python
        len(list_int)
      ```

    * 删除 pop(下标)

      ```python
        list_int.pop(10)
      ```

  * 字典 dict  {}
  
    ```python

      dict_null = {}
      dict_int = {1:1, 2:2, 3,3}
      dict_str = {'a':'aaa', 'b':'ccc', 'c':111, 'd':222}

    ```

    *  添加


  * 元组 tuple ()

    元组内的参数tuple一旦初始化就不能修改

    ```python
      tuple_int = (1,2,3,4,5,6)
      tuple_str = ('a', 'b', 'c', 'd')
    ```



  * set 




## 迭代器(Iterable)

 ```python

   # 姿势1
   for i in range(10):
     print i

   # 姿势1.1
   [i for i in range(10)]

   # 姿势1.2
   [i for i in range if i/2 else i+1]

   # 姿势2
   i = 0
   while i < 10:
     i += i
     print i 


 ```


## 生成器 yied (Generator)

  ```python

  
  ```
  
## 装饰器(Decorator)

  ```python
  
  ```
  
## 异常处理(Exception)
  
  * try except finally
  
    ```python
      try:
        f = x, y: x+y
        f('hello', 123)
      except TypeExceptionError e:
        print e
      finally:
        print '不管是否捕获到异常，我依然执行！'
  
    ```
  * rain()

    ```python

    ```


## 匿名函数 (lambda)
  
  ```python

    func = lambda x, y: x+y

  ```

## 切片

## 排序 (Sort)

# 多线程OR多进程编程

  > 进程是资源分配的基本单位，线程是调度的基本单位。进程包含线程，线程共用进程的资源。

## 线程和进程之间的区别
  
  * 地址空间: 
  
    > 进程内的一个执行单元;
    > 进程至少有一个线程;
    > 它们共享进程的地址空间;
    > 而进程有自己独立的地址空间;

  * 线程是处理器调度的基本单位，进程是系统资源和拥有的单位。

  * 二者均可并发执行

  * 操作系统的设计包括
    * 以多线程形式，允许单个任务分成不同的部分运行
    * 以多进程形式，允许多个任务同时运行

### 进程Process

  进程的基本概念：
    * 举个🌰栗子，进程就是你计算机里面正在运行的一个实例，比方说QQ\Wechat\chrome等等、、、
    * 也就是说在任何类型的系统中进程就是拥有独立系统资源的单位，且进程至少有一个线程
    * 进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源。。

### 线程thread

  * 多线程的基本概念和定义

  * 线程与线程之间的关系

  * 线程同步

    * mutex(互斥锁)线程互斥:

      一个防止其它线程共用一个资源的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。

    * 线程同步

    * 调度
      
      在传统的操作系统中，CPU的调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，
      这样子线程便能轻装运行，也可以很明显的提高系统的并发性。

      * 1、 我们说同一个进程中的线程切换不会引起进程间的切换，从而更好的避免了昂贵的系统资源调用。
      * 2、 但是在一个进程中的线程切换到另外一个进程中的线程时，依然会引发进程间的切换问题。
    
    * 并发

      在引入线程的操作系统中，不仅仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性能，从而能更有效的使用系统和提高系统的吞吐量。

      > 譬如：在一个未引入多线程或者线程的操作系统中，若只设置一个文件服务进程，当它由于某种原因被封锁的时候，便没有其它的文件服务进程来提供服务。









## 正则表达式

   * 1.模式字符串使用特殊的语法来表示一个正则表达式：
   * 2.字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。
   * 3.多数字母和数字前加一个反斜杠时会拥有不同的含义。
   * 4.标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
   * 5.反斜杠本身需要使用反斜杠转义。
   * 6.由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’/t’，等价于’//t’)匹配相应的特殊字符。
   * 7.下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。
   
      ```python
         .    匹配除 "\n" 之外的任何单个字符。如果要匹配包括 '\n' 在内的任何字符，可使用像 '[.\n]'或者'[\s\S]' 的模式。
         \d    匹配一个数字字符。等价于 [0-9]。
         \D     匹配一个非数字字符。等价于 [^0-9]。
         \s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
         \S     匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
         \w    匹配字母数字。等价于'[A-Za-z0-9_]'。
         \W    匹配任何非字母数字。等价于 '[^A-Za-z0-9_]'。
         \b    匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
         \B    匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
         ^    匹配字符串的开头
         $    匹配字符串的末尾。
         [...]    用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
         [^...]    不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
         re*    匹配0个或多个的表达式。
         re+    匹配1个或多个的表达式。
         re?    匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
         re{ n}    
         re{ n,}    精确匹配n个前面表达式。
         re{ n, m}    匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
         a| b    匹配a或b
         (re)    G匹配括号内的表达式，也表示一个组
      ```
